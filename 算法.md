# 二分查找

## 704.二分查找

>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```java
class Solution {
    public int search(int[] nums, int target) {
		int left = 0, right = nums.length - 1;
        while (left <= right){
            int mid = left + (right - left) / 2;
            if (nums[mid] == target){
                return mid;
            }else if(nums[mid] < target){
                left = mid + 1;
            }else {
                right = mid - 1;
            }
        }
        return -1;
    }
}
```

标准的二分，采用闭区间搜索的方式，所以循环条件是`left <= right`

注意用`int mid = left + (right - left) / 2;`防止计算溢出

## 278.第一个错误的版本

>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
>
>假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
>
>你可以通过调用` boolean isBadVersion(version) `接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

```java
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int left = 1,right = n;
        // 循环直至区间左右端点相同
        while (left < right){
            int mid = left + (right - left) / 2;
            if (isBadVersion(mid)){
                // 答案在区间 [left, mid] 中
                right = mid;
            }else {
                // 答案在区间 [mid+1, right] 中
                left = mid + 1;
            }
        }
        // 此时有 left == right，区间缩为一个点，即为答案
        return right;
    }
}
```

本题与上题虽然都采用闭区间搜索的方式，但是由于本题是找第一个目标，而不是找到即可，所以循环结束条件为`left < right`，让其缩至一个点后退出循环，若加上等于号，则会无限循环。

## 35.搜索插入位置

>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
>请必须使用时间复杂度为 O(log n) 的算法。



```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right){
            int mid = left + (right - left) / 2;
            if (nums[mid] == target){
                return mid;
            }else if(nums[mid] < target) {
                left = mid + 1;
            }else {
                right = mid - 1;
            }
        }
        return left;
    }
}
```

除了最后的`return left;`其余都与二分查找一样。

若没有找到目标，则`left`最终一定等于`right+1`（因为最后一次循环时`left == right`，如果还没找到那么要么`left = mid + 1`要么`right = mid - 1`），所以最终答案一定在`left`的位置。（因为如果最后一次循环，若有`nums[mid] < target`，那么一定在`mid + 1`处插入，而`left = mid + 1`，若有`nums[mid] > target`，那么一定在mid处插入，因为此时`nums[mid - 1] < target`，而此时`left = mid`，`right = mid - 1`）。

## 34.在排序数组中查找元素的第一个和最后一个位置

> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>
> 如果数组中不存在目标值 target，返回 [-1, -1]。



```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0){
            return new int[]{-1,-1};
        }
        List<Integer> list = new ArrayList<>();
        for (int num : nums){
            list.add(num);
        }
        return new int[]{list.indexOf(target),list.lastIndexOf(target)};
    }
}
```

这是调库的做法。

下面是标准二分。

```JAVA
class Solution {
    public int[] searchRange(int[] nums, int target) {
        return new int[]{findFirst(nums,target),findLast(nums,target)};
    }
    private int findFirst(int[] nums,int target){
        if (nums.length == 0){
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right){
            int mid = left + (right - left ) / 2;
            if (nums[mid] == target){
                right = mid - 1;
            }else if (nums[mid] < target) {
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        if (left >= nums.length || nums[left] != target) {
            return -1;
        }
        return left;
    }
    private int findLast(int[] nums,int target){
        if (nums.length == 0){
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right){
            int mid = left + (right - left ) / 2;
            if (nums[mid] == target){
                left = mid + 1;
            }else if (nums[mid] < target) {
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        if (right < 0 || nums[right] != target) {
            return -1;
        }
        return right;
    }
}
```

只考虑寻找左边界（右边界对称），先说下左边界的含义，对于数组{1,2,2,2,3}找2，我们返回1，实际上就是数组中小于2的元素有一个，也就是1，对于数组｛2，3，5，7｝找8，我们算法返回4，也就是数组中小于8的有4个，所以函数返回值（也就是left的值）的取值区间是[0,length]，所以要判断出界，出界或者找不到的时候返回-1即可，这是边界处理问题。

```JAVA
//边界处理
if (left >= nums.length || nums[left] != target) {
            return -1;
        }
```

我们在`nums[mid] == target`时，不能立即返回，这是和二分查找不一样的情况，而是应该用`right = mid - 1;`因为是找第一个，所以缩小搜索右边界继续搜索，这里不用`right = mid`是因为考虑若区间[left,mid - 1]没有目标，那么根据刚才探究的出界特性，left会和mid相等，也就是我们刚才如果找到目标值的下标，我们返回的是left，所以这种情况符合，所以应该用`right = mid - 1;`。我们选择返回left的原因是，循环结束后，left = right + 1，而我们在找到目标后，有right = mid - 1，也就是mid = right + 1，所以此时left和mid相等，我们返回left。

二分查找寻找左边界的思路就是把普通二分查找的相等情况，不返回，而是缩小右边界`right = mid - 1;`，然后判断是否越界和不存在`if (left >= nums.length || nums[left] != target) `，如果有，则返回-1，如果没有，返回left。



## 33.搜索旋转排序数组

>整数数组 nums 按升序排列，数组中的值 互不相同 。
>
>在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
>
>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。



```JAVA
class Solution {
    public int search(int[] nums, int target) {
        int index = 0;
        int n = nums.length;
        for (int i = 0;i < n - 1 ;i++ ) {
            if (nums[i] > nums[i+1]) {
                index = i + 1;
            }
        }
        int[] arr = rotate(nums,n - index);
        int i = binarySearch(arr,target);
        if (i == -1) {
            return -1;
        }else{
            return (i + index) % n;
        }
    }
    //将数组nunms向右移动k个位置
    public int[] rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;
        int[] ret = new int[n];
        System.arraycopy(nums,n - k,ret,0,k);
        System.arraycopy(nums,0,ret,k,n - k);
        return ret;
    }
    private int binarySearch(int[] nums,int target){
        int l = 0,r = nums.length - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] == target) {
                return mid;
            }else if (nums[mid] < target) {
                l = mid + 1;
            }else {
                r = mid - 1;
            }
        }
        return -1;
    }
}
```

旋转回去再二分。



## 74.搜索二维矩阵

>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
>
>每行中的整数从左到右按升序排列。
>每行的第一个整数大于前一行的最后一个整数。

```JAVA
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        int i = 0 , j = n - 1;
        while (i < m && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            }else if (matrix[i][j] > target) {
                j--;
            }else if (matrix[i][j] < target) {
                i++;
            }
        }
        return false;
    }
}
```

从矩阵的右上角开始搜，如果大了就把这一列去掉，如果小了就把这一行去掉，去掉后从新矩阵的右上角继续。

![image-20210807102736557](typora-user-images\image-20210807102736557.png)

比如在这个矩阵搜30，从7开始，小了，把第一行去掉，然后是20，小了，把第二行去掉，然后是60，大了，把最后一列去掉，然后是34，大了，把倒数第二列去掉，然后是30，搜索成功。



## 153.寻找旋转排序数组中的最小值

> 
> 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：
>
> - 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
> - 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`
>
> 注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。
>
> 给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。



```JAVA
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n-1 ;i++ ) {
            if (nums[i] > nums[i+1]) {
                return nums[i+1];
            }
        }
        return nums[0];
    }
}
```



## 162.寻找峰值

>峰值元素是指其值大于左右相邻值的元素。
>
>给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
>
>你可以假设 nums[-1] = nums[n] = -∞ 。



 ```JAVA
 public class Solution {
     public int findPeakElement(int[] nums) {
         for (int i = 0; i < nums.length - 1; i++) {
             if (nums[i] > nums[i + 1])
                 return i;
         }
         return nums.length - 1;
     }
 }
 ```





# 双指针

## 977.有序数组的平方

> 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] res = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            res[i] = (int)Math.pow(nums[i],2);
        }
        Arrays.sort(res);
        return res;
    }
}
```

最简单的做法就是如上，先平方再排序。

![image-20210730101605648](typora-user-images\image-20210730101605648.png)

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int negative = -1;
        for (int i = 0; i < n; ++i) {
            if (nums[i] < 0) {
                negative = i;
            } else {
                break;
            }
        }

        int[] ans = new int[n];
        int index = 0, i = negative, j = negative + 1;
        while (i >= 0 || j < n) {
            if (i < 0) {
                ans[index] = nums[j] * nums[j];
                ++j;
            } else if (j == n) {
                ans[index] = nums[i] * nums[i];
                --i;
            } else if (nums[i] * nums[i] < nums[j] * nums[j]) {
                ans[index] = nums[i] * nums[i];
                --i;
            } else {
                ans[index] = nums[j] * nums[j];
                ++j;
            }
            ++index;
        }

        return ans;
    }
}
```

## 189.旋转数组

> 给定一个数组，将数组中的元素向右移动 `k` 个位置，其中 `k` 是非负数。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;
        int[] ret = new int[n];
        System.arraycopy(nums,n - k,ret,0,k);
        System.arraycopy(nums,0,ret,k,n - k);
        System.arraycopy(ret,0,nums,0,n);
    }
}
```

## 283.移动零

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length, left = 0, right = 0;
        while (right < n) {
            if (nums[right] != 0) {
                swap(nums, left, right);
                left++;
            }
            right++;
        }
    }

    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
```

左指针指向已经处理好的数组的末尾（一定是第一个0，因为已经让右指针遍历过了），让右指针一直向右移动，遇到不为0的就与左指针交换。

## 167.两数之和-输入有序数组

> 给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。
>
> 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。
>
> 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
>

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int n = numbers.length;
        int left = 0,right = n - 1;
        while (left < right){
            if (numbers[left] + numbers[right] == target){
                return new int[]{left+1,right+1};
            }else if (numbers[left] + numbers[right] > target){
                right--;
            }else {
                left++;
            }
        }
        return new int[]{-1, -1};
    }
}
```

分左右指针往里缩即可。

## 344.反转字符串

>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
>
>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
>
>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。



```java
class Solution {
   public void reverseString(char[] s) {
        int n = s.length;
        if (n == 0 || n == 1){
            return;
        }
        int left = 0, right = n - 1;
        while (left<=right){
            exchange(s,left,right);
            left++;
            right--;
        }
    }
    private void exchange(char[] s,int left, int right){
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
    }
}
```

## 557.反转字符串中的单词III

> 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

```java
class Solution {
    public String reverseWords(String s) {
        int n = s.length();
        if (n == 0){
            return "";
        }
        char[] c = s.toCharArray();
        List<Integer> spaces = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (c[i] == ' '){
                spaces.add(i);
            }
        }
        if (spaces.isEmpty()){
            reverseString(c,0,n-1);
        }else{
            int len = spaces.size();
            for (int i = 0; i <= len; i++) {
                if (i < len) {
                    int index = spaces.get(i);
                    if (i == 0) {
                        reverseString(c, 0, index - 1);
                    } else {
                        reverseString(c, spaces.get(i - 1) + 1, index - 1);
                    }
                }else{
                    int index = spaces.get(len - 1);
                    reverseString(c, index + 1,n - 1);
                }
            }
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.append(c[i]);
        }
        return sb.toString();
    }
    private void reverseString(char[] s,int left,int right) {
        while (left<=right){
            exchange(s,left,right);
            left++;
            right--;
        }
    }
    private void exchange(char[] s,int left, int right){
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
    }
}
```

记录空格位置，反转两个空格之间的字符串。注意若空格一共n个，则需反转n+1个字符串。

## 876.链表的中间节点

>给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。
>
>如果有两个中间结点，则返回第二个中间结点。



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
    ListNode[] A = new ListNode[100];
        int t = 0;
        while (head != null) {
            A[t++] = head;
            head = head.next;
        }
        return A[t / 2];
    }
}
```

## 19.删除链表的倒数第N个节点

> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode myHead = new ListNode(0, head);
        int length = getLength(head);
        ListNode cur = myHead;
        for (int i = 1; i < length - n + 1; ++i) {
            cur = cur.next;
        }
        cur.next = cur.next.next;
        ListNode ans = myHead.next;
        return ans;
    }

    public int getLength(ListNode head) {
        int length = 0;
        while (head != null) {
            ++length;
            head = head.next;
        }
        return length;
    }
}
```

## 82.删除排序链表中的重复元素II

> 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。
>
> 返回同样按升序排列的结果链表。

```JAVA
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return head;
        }
        
        ListNode dummy = new ListNode(0, head);

        ListNode cur = dummy;
        while (cur.next != null && cur.next.next != null) {
            if (cur.next.val == cur.next.next.val) {
                int x = cur.next.val;
                while (cur.next != null && cur.next.val == x) {
                    cur.next = cur.next.next;
                }
            } else {
                cur = cur.next;
            }
        }

        return dummy.next;
    }
}
```

![image-20210809195532602](typora-user-images\image-20210809195532602.png)

![image-20210809195537978](typora-user-images\image-20210809195537978.png)

一次遍历，出现循环的特征是`cur.next.val == cur.next.next.val`,注意判空，然后记录这个值，x，让cur的next不断指向不为x的第一个元素。



## 15.三数之和

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。

![image-20210809200042712](typora-user-images\image-20210809200042712.png)

```JAVA
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> lists = new ArrayList<>();
        //排序
        Arrays.sort(nums);
        //双指针
        int len = nums.length;
        for(int i = 0;i < len;++i) {
            if(nums[i] > 0) return lists;

            if(i > 0 && nums[i] == nums[i-1]) continue;

            int curr = nums[i];
            int L = i+1, R = len-1;
            while (L < R) {
                int tmp = curr + nums[L] + nums[R];
                if(tmp == 0) {
                    List<Integer> list = new ArrayList<>();
                    list.add(curr);
                    list.add(nums[L]);
                    list.add(nums[R]);
                    lists.add(list);
                    while(L < R && nums[L+1] == nums[L]) ++L;
                    while (L < R && nums[R-1] == nums[R]) --R;
                    ++L;
                    --R;
                } else if(tmp < 0) {
                    ++L;
                } else {
                    --R;
                }
            }
        }
        return lists;
    }
}
```

令左指针是i+1是因为从左往右找，去除重复解，比如下标是3，6，8的相加为0，当i=3的时候，可以拿出3，6，8，当i=6的时候，就不会再添加进去3，6，8这样，i是一个起点，以i为左边界，在整个数组的i的右边找，排除重复解。

## 844.比较含退格的字符串

> 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。
>
> 注意：如果对空文本输入退格字符，文本继续为空。

```JAVA
class Solution {
    public boolean backspaceCompare(String s, String t) {
        return build(s).equals(build(t));
    }
    private String build(String s){
        StringBuffer sb = new StringBuffer();
        for (int i = 0;i < s.length();i++ ) {
            if (s.charAt(i)!='#') {
                sb.append(s.charAt(i));
            }else{
                if (sb.length() > 0) {
                    sb.deleteCharAt(sb.length() - 1);
                }
            }
        }
        return sb.toString();
    }
}
```

重构字符串。  注意stringbuffer的`deleteCharAt`方法。

## 986.区间列表的交集

> 给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。
>
> 返回这 两个区间列表的交集 。
>
> 形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b 。
>
> 两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。

![image-20210810105807128](typora-user-images\image-20210810105807128.png)

```JAVA
class Solution {
  public int[][] intervalIntersection(int[][] A, int[][] B) {
    List<int[]> ans = new ArrayList();
    int i = 0, j = 0;

    while (i < A.length && j < B.length) {
      // Let's check if A[i] intersects B[j].
      // lo - the startpoint of the intersection
      // hi - the endpoint of the intersection
      int lo = Math.max(A[i][0], B[j][0]);
      int hi = Math.min(A[i][1], B[j][1]);
      if (lo <= hi)
        ans.add(new int[]{lo, hi});

      // Remove the interval with the smallest endpoint
      if (A[i][1] < B[j][1])
        i++;
      else
        j++;
    }

    return ans.toArray(new int[ans.size()][]);
  }
}

```

![image-20210813160008309](typora-user-images\image-20210813160008309.png)

## 11.盛水最多的容器

> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
>
> 说明：你不能倾斜容器。

![image-20210810104014403](typora-user-images\image-20210810104014403.png)

```JAVA
public class Solution {
    public int maxArea(int[] height) {
        int l = 0, r = height.length - 1;
        int ans = 0;
        while (l < r) {
            int area = Math.min(height[l], height[r]) * (r - l);
            ans = Math.max(ans, area);
            if (height[l] <= height[r]) {
                ++l;
            }
            else {
                --r;
            }
        }
        return ans;
    }
}

```

本题是一道经典的双指针题目。

![image-20210810104707477](typora-user-images\image-20210810104707477.png)

![image-20210810104719443](typora-user-images\image-20210810104719443.png)

# 滑动窗口

## 3.无重复字符的最长子串

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

![image-20210730103446758](typora-user-images\image-20210730103446758.png)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        Set<Character> set = new HashSet<>();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int right = -1;
        int ans = 0;
         // i是枚举左指针的位置，初始值隐性地表示为 -1
        for (int i = 0; i < n; i++) {
            if (i > 0){
                //i每+1，代表左指针移动一位，将之前子串的第一位删除，开始找当前左指针开头的最长子串
                set.remove(s.charAt(i - 1));
            }
            //不断移动右指针，对当前右指针，如果下一位没有在集合中，就将下一位放入
            //注意我们初始right是-1，所以这里考虑“下一位”
            while (right < n - 1 && !set.contains(s.charAt(right + 1))){
                set.add(s.charAt(right + 1));
                ++right;
            }
            ans = Math.max(ans,right - i + 1);
        }
        return ans;
    }
}
```

## 567.字符串的排列

>给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。
>
>换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。

![image-20210730104221212](typora-user-images\image-20210730104221212.png)

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int n = s1.length(), m = s2.length();
        if (n > m) {
            return false;
        }
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        //获得s1的cnt1和s2初始窗口的cnt2
        for (int i = 0; i < n; ++i) {
            ++cnt1[s1.charAt(i) - 'a'];
            ++cnt2[s2.charAt(i) - 'a'];
        }
        //判断第一个窗口
        if (Arrays.equals(cnt1, cnt2)) {
            return true;
        }
        for (int i = n; i < m; ++i) {
            //窗口右移并处理两端的数据
            ++cnt2[s2.charAt(i) - 'a'];
            --cnt2[s2.charAt(i - n) - 'a'];
            if (Arrays.equals(cnt1, cnt2)) {
                return true;
            }
        }
        return false;
    }
}
```

这里注意`Arrays.equals()`方法



## 438.找到字符串中所有字母的异位词

> 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
>
> 异位词 指字母相同，但排列不同的字符串。

```JAVA
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int m = s.length(), n = p.length();
        if (m < n) {
            return res;
        }
        int[] cnt1 = new int[26];
        int[] cnt2 = new int[26];
        //获得s的cnt1和p初始窗口的cnt2
        for (int i = 0; i < n; ++i) {
            ++cnt1[s.charAt(i) - 'a'];
            ++cnt2[p.charAt(i) - 'a'];
        }
        //判断第一个窗口
        if (Arrays.equals(cnt1, cnt2)) {
            res.add(0);
        }
        for (int i = n; i < m; ++i) {
            //窗口右移并处理两端的数据
            ++cnt1[s.charAt(i) - 'a'];
            --cnt1[s.charAt(i - n) - 'a'];
            if (Arrays.equals(cnt1, cnt2)) {
                res.add(i-n+1);
            }
        }
        return res;
    }
}
```

其实和上个题一模一样。

## 713.乘积小于K的子数组

> 给定一个正整数数组 `nums`和整数 `k` 。
>
> 请找出该数组内乘积小于 `k` 的连续的子数组的个数。

```JAVA
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if(k <= 1){
            return 0;
        }
        int n = nums.length;
        int ans = 0;
        int start = 0,end = 0;
        int multi = 1;
        while (end < n) {
            multi *= nums[end];
            while (multi >= k) {
                multi /= nums[start++];
            }
            ans += end - start + 1;
            end++;
        }
        return ans;
    }
}
```

思路同209，只不过这个子数组的个数需要注意，也就是核心是`ans += end - start + 1;`

right-left+1的切入点是思维要放在区间的右边往左边延伸，例如区间[1, 2, 3, 4]满足要求，固定住right(4)的点，可选区间右[4]、[4, 3]、[4, 3, 2]、[4, 3, 2, 1]即为数组的长度，也就是right-left+1。而right是递增的，此时[1, 2, 3]的区间已经处理完（[3]、[3, 2]、[3、2、1]）。如果从left为切入点，就会有[1, 2, 3, 4]和[1, 2, 3]都有[1]，不就是重复了的错乱思维。



## 209.长度最小的子数组

> 给定一个含有 n 个正整数的数组和一个正整数 target 。
>
> 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。



```JAVA
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int ans = Integer.MAX_VALUE;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= target) {
                ans = Math.min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
```

一般这种一个数组中连续的部分就是滑动窗口。

![image-20210811215643013](typora-user-images\image-20210811215643013.png)

# BFS/DFS

## 733.图像渲染

> 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。
>
> 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。
>
> 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。
>
> 最后返回经过上色渲染后的图像。

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int m = image.length, n = image[0].length;
        int oldColor = image[sr][sc];
        //这里要注意加上判断 否则下面会无限循环
        if (oldColor == newColor){
            return image;
        }
        Deque<int[]> queue = new ArrayDeque<>();
        queue.offer(new int[]{sr, sc});
        while (!queue.isEmpty()) {
            int[] poll = queue.poll();
            int x = poll[0], y = poll[1];
            image[x][y] = newColor;
            if (x > 0 && image[x - 1][y] == oldColor) {
                queue.offer(new int[]{x - 1, y});
            }
            if (x < m - 1 && image[x + 1][y] == oldColor) {
                queue.offer(new int[]{x + 1, y});
            }
            if (y > 0 && image[x][y - 1] == oldColor) {
                queue.offer(new int[]{x, y - 1});
            }
            if (y < n - 1 && image[x][y + 1] == oldColor) {
                queue.offer(new int[]{x, y + 1});
            }
        }
        return image;
    }
}
```

常规BFS 队列操作

## 695.岛屿的最大面积

> 给定一个包含了一些 0 和 1 的非空二维数组 grid 。
>
> 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
>
> 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)

- DFS
- 我们想知道网格中每个连通形状的面积，然后取最大值。

- 如果我们在一个土地上，以 4个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。

- 为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 0。这样我们就不会多次访问同一土地。

```java
class Solution{
    public int maxAreaOfIsland(int[][] grid) {
        int ans = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                ans = Math.max(ans, dfs(grid, i, j));
            }
        }
        return ans;
    }

    private int dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || grid[i][j] == 0) {
            return 0;
        }
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};
        //置为0表示访问过
        grid[i][j] = 0;
        int ans = 1;
        for (int k = 0; k < 4; k++) {
            int x = i + dx[k], y = j + dy[k];
            ans += dfs(grid, x, y);
        }
        return ans;
    }
}
```

比较经典的搜索题，思路是遍历矩阵中每个点，对每个点用dfs搜最岛屿面积，记录最大的。

dsf过程就用dx和dy表示前进的方向，获得下一组的坐标，一共四个方向，所以循环四次，然后递归调用dfs方法。

dfs方法前半部分就是处理递归边界，以及处理矩阵访问过的置为0，并且记录一个面积到ans中，最后递归调用，不断累加ans。

## 617.合并二叉树

> 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
>
> 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null || root2 == null) {
            return root1 == null ? root2 : root1;
        }
        TreeNode root = new TreeNode(root1.val+root2.val);
        root.left = mergeTrees(root1.left,root2.left);
        root.right = mergeTrees(root1.right,root2.right);
        return root;
    }
}
```

dfs，递归调用来合并，注意处理好递归边界。

## 116.填充每个节点的下一个右侧节点指针

> 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
>
> ```c
> struct Node {
>   	int val;
>   	Node *left;
>   	Node *right;
>   	Node *next;
> }
> 
> ```
>
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
>
> 初始状态下，所有 next 指针都被设置为 NULL。

![image-20210731132403041](typora-user-images\image-20210731132403041.png)



```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if (root == null) {
            return root;
        }
        if (root.left != null) {
            root.left.next = root.right;
            root.right.next = root.next == null ? null : root.next.left;
            connect(root.left);
            connect(root.right);
        }
        return root;
    }
}
```

注意二叉树很多题都能递归，这里递归要利用已经建立好的`next`指针。

很显然因为是完全二叉树，所以我们只需判断左子树为不为空即可。如果有左右子结点，那么左子节点的next指针一定指向右子节点，问题是右子节点的next往哪指，这时候就要看root的next指针了：

![image-20210731133350204](typora-user-images\image-20210731133350204.png)

对于1这个root，它的next是null，则它的右子节点的next指向null。

递归调用到2的时候，对于以2为根节点的树来说，2的next为3，那么2的右子节点5就要指向3的left也就是6，所以就有了

`root.right.next = root.next == null ? null : root.next.left;`。这是本题的关键。

## 542.01矩阵

>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。
>
>两个相邻元素间的距离为 1 。

```java

class Solution {
    public int[][] updateMatrix(int[][] matrix) {
        // 首先将所有的 0 都入队，并且将 1 的位置设置成 -1，表示该位置是 未被访问过的 1
        Queue<int[]> queue = new LinkedList<>();
        int m = matrix.length, n = matrix[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    queue.offer(new int[] {i, j});
                } else {
                    matrix[i][j] = -1;
                } 
            }
        }
        
        int[] dx = new int[] {-1, 1, 0, 0};
        int[] dy = new int[] {0, 0, -1, 1};
        while (!queue.isEmpty()) {
            int[] point = queue.poll();
            int x = point[0], y = point[1];
            for (int i = 0; i < 4; i++) {
                int newX = x + dx[i];
                int newY = y + dy[i];
                // 如果四邻域的点是 -1，表示这个点是未被访问过的 1
                // 所以这个点到 0 的距离就可以更新成 matrix[x][y] + 1。
                if (newX >= 0 && newX < m && newY >= 0 && newY < n 
                        && matrix[newX][newY] == -1) {
                    matrix[newX][newY] = matrix[x][y] + 1;
                    queue.offer(new int[] {newX, newY});
                }
            }
        }

        return matrix;
    }
}
```

本题思路是从0开始遍历，注意区分被访问过的1与没有被访问过的1，因为如果将被访问过的1的距离记为s，那么他的四周如果还有1，那么四周的1的距离就是s+1，所以要将访问过的1入队。

## 994.腐烂的橘子

>在给定的网格中，每个单元格可以有以下三个值之一：
>
>- 值 0 代表空单元格；
>- 值 1 代表新鲜橘子；
>- 值 2 代表腐烂的橘子。
>
>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
>
>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。



```java
class Solution {
    public int orangesRotting(int[][] grid) {


    // 边界 长宽
    int M = grid.length;
    int N = grid[0].length;
    Queue<int[]> queue = new LinkedList<>();

    // count 表示新鲜橘子的数量
    int count = 0; 

    // 遍历二维数组 找出所有的新鲜橘子和腐烂的橘子
    for (int r = 0; r < M; r++) {
        for (int c = 0; c < N; c++) {
            // 新鲜橘子计数
            if (grid[r][c] == 1) {
                count++;
                // 腐烂的橘子就放进队列
            } else if (grid[r][c] == 2) {
                // 缓存腐烂橘子的坐标
                queue.add(new int[]{r, c});
            }
        }
    }

    // round 表示腐烂的轮数，或者分钟数
    int round = 0; 

    // 如果有新鲜橘子 并且 队列不为空
    // 直到上下左右都触及边界 或者 被感染的橘子已经遍历完
    while (count > 0 && !queue.isEmpty()) {

        // BFS 层级 + 1
        round++;

        // 拿到当前层级的腐烂橘子数量， 因为每个层级会更新队列
        int n = queue.size();

        // 遍历当前层级的队列
        for (int i = 0; i < n; i++) {

            // 踢出队列（拿出一个腐烂的橘子）
            int[] orange = queue.poll();

            // 恢复橘子坐标
            int r = orange[0];
            int c = orange[1];

            // ↑ 上邻点 判断是否边界 并且 上方是否是健康的橘子
            if (r-1 >= 0 && grid[r-1][c] == 1) {
                // 感染它 
                grid[r-1][c] = 2;
                // 好橘子 -1 
                count--;
                // 把被感染的橘子放进队列 并缓存
                queue.add(new int[]{r-1, c});
            }
            // ↓ 下邻点 同上
            if (r+1 < M && grid[r+1][c] == 1) {
                grid[r+1][c] = 2;
                count--;
                queue.add(new int[]{r+1, c});
            }
            // ← 左邻点 同上
            if (c-1 >= 0 && grid[r][c-1] == 1) {
                grid[r][c-1] = 2;
                count--;
                queue.add(new int[]{r, c-1});
            }
            // → 右邻点 同上
            if (c+1 < N && grid[r][c+1] == 1) {
                grid[r][c+1] = 2;
                count--;
                queue.add(new int[]{r, c+1});
            }
        }
    }

    // 如果此时还有健康的橘子
    // 返回 -1
    // 否则 返回层级
    if (count > 0) {
        return -1;
    } else {
        return round;
    }
    }
}

```



## 200.岛屿数量

> 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
>
> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
>
> 此外，你可以假设该网格的四条边均被水包围。

```JAVA
class Solution {
    public int numIslands(char[][] grid) {
        int m = grid.length,n = grid[0].length;
        int ans = 0;
        for (int i = 0; i < m ;i++ ) {
            for (int j = 0; j < n ;j++ ) {
                if (grid[i][j] == '1') {
                    ans++;
                    dfs(grid,i,j);
                }
            }
        }
        return ans;
    }
    public void dfs(char[][] grid,int i,int j){
        int m = grid.length,n = grid[0].length;
        if (grid[i][j] == '0') {
            return ;
        }
        grid[i][j] = '0';
        int[] dx = new int[]{1,-1,0,0};
        int[] dy = new int[]{0,0,1,-1};
        for (int k = 0; k < 4 ;k++ ) {
            int x = i + dx[k];
            int y = j + dy[k];
            if (x >= 0 && x <= m - 1 && y >= 0 && y <= n - 1) {
                dfs(grid,x,y);
            }
        }
    }
}
```

常规dfs，只是在dfs过程中，注意遍历一个1，就赋值为0即可。

## 547.省份数量

> 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
>
> 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
>
> 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。
>
> 返回矩阵中 省份 的数量。

```JAVA
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        boolean[] visited = new boolean[n];
        int ans = 0;
        for (int i = 0; i < n ; i ++ ) {
            if (!visited[i]) {
                dfs(isConnected,i,visited);
                ans++;
            }
        }
        return ans;
    }
    public void dfs(int[][] isConnected,int i,boolean[] visited){
        int n = isConnected.length;
        visited[i] = true;
        for (int j = 0; j < n; j++ ) {
            if (isConnected[i][j] == 1 && !visited[j]) {
                dfs(isConnected,j,visited);
            }
        }
    }
}
```

思路就是dfs。

## 117.填充每个节点的下一个右侧节点II

> 给定一个二叉树
>
> struct Node {
>   int val;
>   Node *left;
>   Node *right;
>   Node *next;
> }
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
>
> 初始状态下，所有 next 指针都被设置为 NULL。

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if (root == null) {
            return null;
        }
        Queue<Node> queue = new LinkedList<Node>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            //记录每一层的个数
            int n = queue.size();
            Node last = null;
            for (int i = 1; i <= n; ++i) {
                //依次弹出每一层的每一个节点
                Node f = queue.poll();
                if (f.left != null) {
                    queue.offer(f.left);
                }
                if (f.right != null) {
                    queue.offer(f.right);
                }
                //如果不是每一层的第一个节点 就开始连接next指针
                if (i != 1) {
                    last.next = f;
                }
                //如果是第一个节点 直接赋值
                //如果不是第一个节点 连接了next节点后赋值 符合逻辑
                last = f;
            }
        }
        return root;
    }

}
```



## 572.另一棵树的子树

>
> 给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。
>
> 二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。

```JAVA
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        return dfs(s, t);
    }

    public boolean dfs(TreeNode s, TreeNode t) {
        if (s == null) {
            return false;
        }
        //判断s和t是否相等或t是s的左子树的子树或t是s的右子树的子树
        return check(s, t) || dfs(s.left, t) || dfs(s.right, t);
    }

    // s和t树相等
    public boolean check(TreeNode s, TreeNode t) {
        if (s == null && t == null) {
            return true;
        }
        if (s == null || t == null || s.val != t.val) {
            return false;
        }
        return check(s.left, t.left) && check(s.right, t.right);
    }
}
```

## 1091.二进制矩阵中的最短路径

> 给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。
>
> 二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：
>
> 路径途经的所有单元格都的值都是 0 。
> 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。
> 畅通路径的长度 是该路径途经的单元格总数。

```JAVA
class Solution {
    
    public int shortestPathBinaryMatrix(int[][] grid) {
		//方向数组
		int[] X = {0,1,1,1,0,-1,-1,-1};
		int[] Y = {1,1,0,-1,-1,-1,0,1};
        int n = grid.length;
        if(grid[0][0] == 1 || grid[n-1][n-1] == 1) {
			//特殊情况特殊考虑，出口和入口被堵死
			return -1;
		}
		//只有一个0的情况
        if(n == 1 && grid[0][0] == 0) {
			return 1;
		}
		//访问数组
        int[][] v = new int[n][n];
		//队列，里面保存int数组为坐标
        Queue<int[]> a = new LinkedList();
		//一开始将起点入队
        a.add(new int[]{0,0});
		//起点标记为已经访问
        v[0][0] = 1;
		//理论上的初值
        int step = 1;
        while (!a.isEmpty()){
            int s =  a.size();
            for (int i = 0; i < s;i++){
                int[] temp = a.poll();
                int x = temp[0];
                int y = temp[1];
                //终止条件
                if(x==n-1 && y==n-1) {
					return step;
				}
                for(int j=0;j<8;j++){
                    int x1 = x + X[j];
                    int y1 = y + Y[j];
					//数组不越界，值为0，没有被访问过才能入队
                    if(x1>=0 && x1<n && y1>=0 && y1<n && grid[x1][y1]==0 && v[x1][y1]!=1){
                        a.add(new int[]{x1,y1});//入队
                        v[x1][y1] = 1;//标记已访问
                    }
                }
            }
            step++;
        }
        return -1;//队列为空即为不能到达终点，返回-1
    }
}
```

最短路径的思路就是BFS。

终止条件要写的位置可以直接从起点来验证。初始我们让起点入队，然后step设为1，表明前进一步，则之后我们每个点的8次for循环，当前每个点的周围都入队后，step++。

## 130.被围绕的区域

> 给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

```JAVA
class Solution {
    public void solve(char[][] board) {
        int m = board.length,n = board[0].length;
		for(int j = 0 ; j < n; j ++){
			dfs(board,0,j);
			dfs(board,m-1,j);
		}
		for(int i = 1 ; i < m - 1; i ++){
			dfs(board,i,0);
			dfs(board,i,n-1);
		}
		for(int i = 0; i < m ; i ++){
			for(int j = 0; j < n ; j ++){
				if(board[i][j] == 'O'){
					board[i][j] = 'X';
				}else if(board[i][j] == 'A'){
					board[i][j] = 'O';
				}
			}
		}
    }
	public void dfs(char[][] board,int i,int j){
		int m = board.length,n = board[0].length;
		if(i < 0 ||i >= m || j < 0 || j >= n || board[i][j] != 'O'){
			return;
		}
		board[i][j] = 'A';
		int[] dx = new int[]{1,-1,0,0};
		int[] dy = new int[]{0,0,1,-1};
		for(int k = 0; k < 4; k++){
			int x = i + dx[k];
			int y = j + dy[k];
			dfs(board,x,y);
		}
	}
}
```

这题要考虑与边界直接临界或间接连接的点，所以不能传统的一个个dfs，而是从边界的点开始搜，搜出所有与边界相连的点，并标记为A，那么剩下的一定都是被X包围的，这样的话只需要最后二重遍历修改一下数组即可。

## 797.所有可能的路径

> 给一个有 n 个结点的有向无环图，找到所有从 0 到 n-1 的路径并输出（不要求按顺序）
>
> 二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ）空就是没有下一个结点了



```JAVA
class Solution {
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(graph,0,ans,path);
        return ans;
    }
    public void dfs(int[][] graph,int i,List<List<Integer>> ans,List<Integer> path){
        int n = graph.length;
        if (i == n - 1) {
            ans.add(new ArrayList<>(path));
            return ;
        }
        for (int j : graph[i]) {
            path.add(j);
            dfs(graph,j,ans,path);
            path.remove(path.size()-1);
        }
    }
}
```

本质还是回溯，回溯终止条件，做选择，进入下一层，撤回选择，只不过这里的选择列表随着每一层变化而变化，所以不需要破坏现场和恢复现场的步骤。

# 递归回溯

## 206.反转链表

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode p = new ListNode();
        while (head != null){
            ListNode q = new ListNode(head.val);
            q.next = p.next;
            p.next = q;
            head = head.next;
        }
        return p.next;
    }
}
```

头插法

## 21.合并两个有序链表

> 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1,ListNode l2) {
		ListNode l3=new ListNode(0);
		ListNode cur=l3;
		while(l1!=null&&l2!=null) {
			if(l1.val<l2.val) {
				cur.next=l1;
				l1=l1.next;
			}
			else {
				cur.next=l2;
				l2=l2.next;
			}
			cur=cur.next;
		}
		cur.next=l1==null?l2:l1;
        l3=l3.next;
		return l3;
	}
}
```

## 77.组合

>给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

```JAVA
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        Deque<Integer> stack = new ArrayDeque<>();
        dfs(n,k,1,stack,res);
        return res;

    }
    private void dfs(int n,int k,int begin,Deque<Integer> stack,List<List<Integer>> res){
        if (stack.size() == k){
            res.add(new ArrayList<>(stack));
            return;
        }
        //因为i从begin开始 从1到begin-1是不会被选择的 所以我们没有必要创建used数组来判断谁要不要选
        for (int i = begin; i <= n; i++) {
            stack.addLast(i);
            dfs(n,k,i+1,stack,res);
            stack.removeLast();
        }

    }
}
```

这题其实与全排列是一个思路，都是回溯方法，只不过没有必要创建used数组了，我们定义一个begin变量，让选择列表变为begin到n，如果以n=5，k=3为例，回溯过程如下：

第一层： i = 1，stack = [1]，开始递归

第二层： i = 2，stack=[1,2]，开始递归

第三层： i = 3，stack=[1,2,3]，开始递归

第四层： stack.size=3 == k，返回

第三层：进入下一次循环，i = 4 stack=[1,2,4]，开始递归。

...

只要搞清楚递归的层次与循环进行的程度就可。

大致回溯模版如下

```JAVA
public void dfs(...){
    //递归出口
    if(depth == length){
        res.add(new ArrayList<>())
        return;
    }
    
    //开始递归-回溯
    for(选择列表中的每一个选择){
        //做选择
        stack.addLast(选择);
        //破坏现场
        visited[选择]=true;
        //开始递归
        dfs(...);
        //恢复现场
        visited[选择]=false;
        //撤销选择
        stack.removeLast();
        //下一次循环做选择
    }
}
```

剪枝：

![image-20210805120731835](typora-user-images\image-20210805120731835.png)

![image-20210805120813416](typora-user-images\image-20210805120813416.png)

```java
for (int i = begin; i <= n; i++) {
            stack.addLast(i);
            dfs(n,k,i+1,stack,res);
            stack.removeLast();
        }
```

变为

```java
for (int i = begin; i <= n - (k - path.size()) + 1; i++) {
            stack.addLast(i);
            dfs(n,k,i+1,stack,res);
            stack.removeLast();
        }
```



## 46.全排列

> 给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

```JAVA
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        // 使用一个动态数组保存所有可能的全排列
        List<List<Integer>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }

        boolean[] used = new boolean[len];
        Deque<Integer> path = new ArrayDeque<>();

        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     Deque<Integer>path, boolean[] used,
                     List<List<Integer>> res) {
        //递归出口
        if (depth == len) {
            res.add(new ArrayList<>(path));
            return;
        }

        // 在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。
        for (int i = 0; i < len; i++) {
            if (!used[i]) {
                //做选择
                path.addLast(nums[i]);
                //破坏现场
                used[i] = true;
				//递归
                dfs(nums, len, depth + 1, path, used, res);
                // 注意：下面这两行代码发生 「回溯」，回溯发生在从 深层结点 回到 浅层结点 的过程，代码在形式上和递归之前是对称的
                //恢复现场
                used[i] = false;
                //撤销选择
                path.removeLast();
                //下一次循环
            }
        }
    }
}
```

先注意一点：

```JAVA
if (depth == len) {
	res.add(new ArrayList<>(path));
	return;
}

	//错误写法
if (depth == len) {
	res.add(path);
	return;
}
```

这个错误写法是因为java是值传递，如果你add的是path，传进去是引用变量的地址值，那么下面的for循环，有一个` path.remove(path.size() - 1);`会将path中的元素删除，造成添加的path最后变成空list，也就是说整个递归-回溯过程中，path指向一个地方，解决这个问题的方法就是如上再拷贝一份。

递归回溯的dfs，就是做选择（可选择的元素就是for循环下没有被use的元素），破坏现场，递归，恢复现场，撤销选择，可以看出递归的前后是对称的，那么基于这个特点，我们dfs方法的参数必须有path，used。

## 784.字母大小写全排列

> 给定一个字符串`S`，通过将字符串`S`中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

![image-20210805130456522](typora-user-images\image-20210805130456522.png)

```JAVA
class Solution {
    public List<String> letterCasePermutation(String s) {

        List<StringBuilder> ans = new ArrayList<>();
        ans.add(new StringBuilder());
        for (char c : s.toCharArray()) {
            int n = ans.size();
            //如果是字母 就将已经弄好的排列复制为两份，一份加上新的字母的小写，一份加上新的字母的大写
            if (Character.isLetter(c)) {
                for (int i = 0; i < n; i++) {
                    //将第i个字符串复制一份
                    ans.add(new StringBuilder(ans.get(i)));
                    //加上大写
                    ans.get(i).append(Character.toUpperCase(c));
                    //n+i是刚才复制的那一份 加上小写
                    ans.get(i + n).append(Character.toLowerCase(c));
                }
            }//如果是数字，就在每一个字符串后面添上即可
            else {
                for (int i = 0; i < n; i++) {
                    ans.get(i).append(c);
                }
            }

        }
        List<String> res = new ArrayList<>();
        for (StringBuilder sb : ans) {
            res.add(sb.toString());
        }
        return res;
    }
}
```

## 78.子集

> 
> 给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。
>
> 解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

```JAVA
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
		List<Integer> l = new ArrayList<>();
		List<List<Integer>> ans = new ArrayList<>();
		dfs(0,nums,l,ans);
		return ans;
    }
	public void dfs(int cur,int[] nums,List<Integer> l,List<List<Integer>> ans){
		int n = nums.length;
		if(n == cur){
			ans.add(new ArrayList<>(l));
            return;
		}
        //做出选择
		l.add(nums[cur]);
        //进入下一层
		dfs(cur+1,nums,l,ans);
        //撤销选择
		l.remove(l.size()-1);
        //这里也是做选择 只不过做出的选择是不选
        //因为对于nums的每个元素 我们有选择和不选两种状态
        //处于这两种状态之一时 进入下一层dfs
        //由cur变量确定是否处于边界
		dfs(cur+1,nums,l,ans);
	}
}
```

## 90.子集II

> 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
>
> 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

```JAVA
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        int len = nums.length;
        Arrays.sort(nums);      // 排序后便于去重
        dfs(res, new ArrayList<>(), 0, nums.length, nums);
        return res;
    }
    // dfs - 递归函数
    public void dfs(List<List<Integer>> res, List<Integer> list, int index, int len, int[] nums){
        if(index == len){   // [基本情况] 如果游标到达尾部，将当前list拷贝放入res中
            res.add(new ArrayList<>(list));
            return;
        }
        list.add(nums[index]); 
        dfs(res, list, index + 1, len, nums); // 选择当前的数
        list.remove(list.size() - 1);   // 回溯 - 将当前添加的数删除
        while (index < len - 1 && nums[index] == nums[index + 1]){ // 去重，不选当前数递归时直接跳过重复数
            index++;    // 所有重复数的可能性在前面递归中均会出现
        }
        dfs(res, list, index + 1, len, nums); // 不选择当前的数
    }
}
```



## 17.电话号码的字母组合

![image-20210817202805697](typora-user-images\image-20210817202805697.png)

```JAVA
class Solution {
    private char[][] letters;
    public List<String> letterCombinations(String digits) {
        letters = new char[][]{{
                'a','b','c','0'
        },{
                'd','e','f','0'
        },{
                'g','h','i','0'
        },{
                'j','k','l','0'
        },{
                'm','n','o','0'
        },{
                'p','q','r','s'
        },{
                't','u','v','0'
        },{
                'w','x','y','z'
        }};
        int len = digits.length();
        if (len == 0) {
            return new ArrayList<String>();
        }
        List<String> ans = new ArrayList<>();
        StringBuffer sb = new StringBuffer();
        boolean[] visited = new boolean[len];
        backtrace(ans,digits,sb,0,visited);
        return ans;
    }
    public void backtrace(List<String> ans, String digits, StringBuffer sb, int index, boolean[] visited){
        int len = digits.length();
        if (index == len) {
            ans.add(sb.toString());
            return ;
        }
        int num = digits.charAt(index) - 48 - 2;
        for (int j = 0; j < 4 ; j++ ) {
            if (letters[num][j]!='0' && !visited[index]) {
                sb.append(letters[num][j]);
                visited[index] = true;
                backtrace(ans,digits,sb,index+1,visited);
                visited[index] = false;
                sb.deleteCharAt(sb.length() - 1);
            }
        }
    }
}
```

回溯



## 22.括号生成

> 数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
> 有效括号组合需满足：左括号必须以正确的顺序闭合。

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<String>();
        backtrack(ans, new StringBuilder(), 0, 0, n);
        return ans;
    }

    public void backtrack(List<String> ans, StringBuilder cur, int open, int close, int max) {
        if (cur.length() == max * 2) {
            ans.add(cur.toString());
            return;
        }
        if (open < max) {
            cur.append('(');
            backtrack(ans, cur, open + 1, close, max);
            cur.deleteCharAt(cur.length() - 1);
        }
        if (close < open) {
            cur.append(')');
            backtrack(ans, cur, open, close + 1, max);
            cur.deleteCharAt(cur.length() - 1);
        }
    }
}
```

## 79.单词搜索

> 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
>
> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

```JAVA
class Solution {
    public boolean exist(char[][] board, String word) {
        int m = board.length, n = board[0].length;
        boolean[][] visited = new boolean[m][n];
        for (int i = 0; i < m ; i++ ) {
            for (int j = 0; j < n ;j++ ) {
                if (board[i][j] == word.charAt(0)) {
                    if (dfs(board,word,visited,i,j,0)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    public boolean dfs(char[][] board, String word,boolean[][] visited,int i,int j,int depth){
        if (depth == word.length() - 1) {
            return true;
        }
        visited[i][j] = true;
        int m = board.length, n = board[0].length;
        int[] dx = new int[]{1,-1,0,0};
        int[] dy = new int[]{0,0,1,-1};
        boolean found = false;
        boolean flag = false;
        for (int k = 0; k < 4 ; k ++ ) {
            int newI = i + dx[k];
            int newJ = j + dy[k];
            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n && board[newI][newJ] == word.charAt(depth + 1) && !visited[newI][newJ]) {
                found = dfs(board,word,visited,newI,newJ,depth+1);
                if (found) {
                    flag = true;
                }
            }
        }
        visited[i][j] = false;
        return flag;
    }
}
```

## 47.全排列II

> 给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

```JAVA
class Solution {
    boolean[] vis;
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        List<Integer> perm = new ArrayList<Integer>();
        vis = new boolean[nums.length];
        Arrays.sort(nums);
        backtrack(nums, ans, 0, perm);
        return ans;
    }

    public void backtrack(int[] nums, List<List<Integer>> ans, int idx, List<Integer> perm) {
        if (idx == nums.length) {
            ans.add(new ArrayList<Integer>(perm));
            return;
        }
        for (int i = 0; i < nums.length; ++i) {
            if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) {
                continue;
            }
            perm.add(nums[i]);
            vis[i] = true;
            backtrack(nums, ans, idx + 1, perm);
            vis[i] = false;
            perm.remove(idx);
        }
    }
}

```

![image-20210821110220011](typora-user-images\image-20210821110220011.png)

就比如1,1,2，第一次回溯就会填入1,1,2，那么接下来到第二个1先放入了，那么在这个if下，第一个1是没有被访问的，所以满足条件，直接continue，跳过以第二个1为首的排列情况，去重成功。

这里的去重挺通用的。

例如在这道剑指Offer38字符串的排列中

![image-20210821152535627](typora-user-images\image-20210821152535627.png)

```JAVA
class Solution {
    public String[] permutation(String s) {
        int n = s.length();
        StringBuffer sb = new StringBuffer();
        List<String> ans = new ArrayList<>();
        boolean[] visited = new boolean[n];
        char[] array = s.toCharArray();
        Arrays.sort(array);
        dfs(sb, array, 0, ans, visited);
        String[] ret = new String[ans.size()];
        for (int i = 0; i < ans.size(); i++) {
            ret[i] = ans.get(i);
        }
        return ret;
    }

    public void dfs(StringBuffer sb, char[] array, int depth, List<String> ans, boolean[] visited) {
        int n = array.length;
        if (depth == n) {
            ans.add(sb.toString());
            return;
        }
        for (int i = 0; i < n; i++) {
            if (visited[i] || (i > 0 && !visited[i - 1] && array[i] == array[i - 1])) {
                continue;
            }
            sb.append(array[i]);
            visited[i] = true;
            dfs(sb, array, depth + 1, ans, visited);
            visited[i] = false;
            sb.deleteCharAt(sb.length() - 1);

        }
    }
}
```



这里

```JAVA
if (visited[i] || (i > 0 && !visited[i - 1] && array[i] == array[i - 1])) {
                continue;
            }
```

的`(i > 0 && !visited[i - 1] && array[i] == array[i - 1])`就是这个去重思路

## 39.组合总和

> 给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。
>
> candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 
>
> 对于给定的输入，保证和为 target 的唯一组合数少于 150 个。

```JAVA
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        List<Integer> combine = new ArrayList<Integer>();
        dfs(candidates, target, ans, combine, 0);
        return ans;
    }

    public void dfs(int[] candidates, int target, List<List<Integer>> ans, List<Integer> combine, int idx) {
        if (idx == candidates.length) {
            return;
        }
        if (target == 0) {
            ans.add(new ArrayList<Integer>(combine));
            return;
        }
        // 直接跳过
        dfs(candidates, target, ans, combine, idx + 1);
        // 选择当前数
        if (target - candidates[idx] >= 0) {
            combine.add(candidates[idx]);
            dfs(candidates, target - candidates[idx], ans, combine, idx);
            combine.remove(combine.size() - 1);
        }
    }
}
```

## 40.组合总和II

> 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的每个数字在每个组合中只能使用一次。
>
> 注意：解集不能包含重复的组合。 

```JAVA
class Solution {
    List<int[]> freq = new ArrayList<int[]>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();
    List<Integer> sequence = new ArrayList<Integer>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        for (int num : candidates) {
            int size = freq.size();
            if (freq.isEmpty() || num != freq.get(size - 1)[0]) {
                freq.add(new int[]{num, 1});
            } else {
                ++freq.get(size - 1)[1];
            }
        }
        dfs(0, target);
        return ans;
    }

    public void dfs(int pos, int rest) {
        if (rest == 0) {
            ans.add(new ArrayList<Integer>(sequence));
            return;
        }
        if (pos == freq.size() || rest < freq.get(pos)[0]) {
            return;
        }

        dfs(pos + 1, rest);

        int most = Math.min(rest / freq.get(pos)[0], freq.get(pos)[1]);
        for (int i = 1; i <= most; ++i) {
            sequence.add(freq.get(pos)[0]);
            dfs(pos + 1, rest - i * freq.get(pos)[0]);
        }
        for (int i = 1; i <= most; ++i) {
            sequence.remove(sequence.size() - 1);
        }
    }
}

```

![image-20210821111615320](typora-user-images\image-20210821111615320.png)

![image-20210821111604368](typora-user-images\image-20210821111604368.png)

# 动态规划

## 70.爬楼梯

>假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。
>
>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
>**注意：**给定 *n* 是一个正整数。



```java
class Solution {
    public int climbStairs(int n) {
        int p=0,q=0,r=1;
        for(int i=1;i<=n;i++){
            p=q;
            q=r;
            r=p+q;
        }
        return r;
    }
}
```

## 198.打家劫舍

>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。



```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1){
            return nums[0];
        }
        if (n == 2){
            return Math.max(nums[0],nums[1]);
        }
        int[] f = new int[n];
        f[0] = nums[0];
        f[1] = Math.max(nums[0],nums[1]);
        for (int i = 2; i < n; i++) {
            f[i] = Math.max(f[i-1],f[i-2]+nums[i]);
        }
        return f[n-1];
    }
}
```

因为连续打劫两家会失败 所以打劫第i家的的动态规划在`f(i) = max(f(i-1),f(i-2)+nums[i])`

## 120.三角形的最小路径和

>给定一个三角形 triangle ，找出自顶向下的最小路径和。
>
>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
>

![image-20210805094318078](typora-user-images\image-20210805094318078.png)

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int m = triangle.size();
        if (m == 1){
            return triangle.get(0).get(0);
        }
        int[][] f = new int[m][m];
        f[0][0] = triangle.get(0).get(0);
        for (int i = 1; i < m; i++) {
            f[i][0] = f[i-1][0] + triangle.get(i).get(0);
            for (int j = 1; j < i; j++) {
                f[i][j] = Math.min(f[i-1][j-1],f[i-1][j])+triangle.get(i).get(j);
            }
            f[i][i] = f[i-1][i-1] + triangle.get(i).get(i);
        }
        int min = f[m-1][0];
        for (int i = 0; i < m; i++) {
            min = Math.min(f[m-1][i],min);
        }
        return min;
    }
}
```

## 213.打家劫舍II

> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

```JAVA
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }else if(n == 2){
            return Math.max(nums[0],nums[1]);
        }
        //[0,n - 2]
        int[] dp1 = new int[n];
        dp1[0] = nums[0];
        dp1[1] = Math.max(nums[0],nums[1]);
        for (int i = 2; i < n - 1 ;i++ ) {
            dp1[i] = Math.max(dp1[i-2]+nums[i],dp1[i-1]);
        }
        //[1,n - 1]
        int[] dp2 = new int[n];
        //把1~n - 1当做0~n - 2即可
        dp2[0] = nums[1];
        dp2[1] = Math.max(nums[1],nums[2]);
        for (int i = 2; i < n - 1 ;i++ ) {
            dp2[i] = Math.max(dp2[i-2]+nums[i + 1],dp2[i-1]);
        }
        return Math.max(dp1[n - 2],dp2[n - 2]);
    }
}
```

分为偷第一个屋子和偷最后一个屋子的情况，如果偷第一个屋子，那么偷的范围是[0,n-2]，开始动态规划，如果偷最后一个屋子，那么偷的范围是[1,n-1]，动态规划，然后取两种情况的最大值。

## 55.跳跃游戏

> 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个下标。

```JAVA
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int farthest = 0;
        for (int i = 0; i < n; i++ ) {
            if (i <= farthest) {
                farthest = Math.max(farthest,i + nums[i]);
                if (farthest >= n - 1) {
                       return true;
                }   
            }
        }
        return false;
    }
}
```

维护一个最远可到达下标。

![image-20210818144113646](typora-user-images\image-20210818144113646.png)

## 45.跳跃游戏II

> 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>
> 假设你总是可以到达数组的最后一个位置。

![image-20210819102739546](typora-user-images\image-20210819102739546.png)

```JAVA
class Solution {
    public int jump(int[] nums) {
        int position = nums.length - 1;
        int steps = 0;
        while (position > 0) {
            //从距离position最远的开始找起
            for (int i = 0; i < position; i++) {
                //从i可以到达position 就更新position为i
                //并且steps++ 跳一步
                if (i + nums[i] >= position) {
                    position = i;
                    steps++;
                    break;
                }
            }
        }
        return steps;
    }
}
```

正向查找

![image-20210819103858350](typora-user-images\image-20210819103858350.png)

```JAVA
class Solution {
    //每次在上次能跳到的范围（end）内选择一个能跳的最远的位置（也就是能跳到maxPosition位置的点）作为下次的起跳点 ！
    public int jump(int[] nums) {
        int length = nums.length;
        // 上次跳跃可达范围右边界（下次的最右起跳点）
        int end = 0;    
        // 目前能跳到的最远位置
        int maxPosition = 0; 
        //跳跃次数
        int steps = 0;
        for (int i = 0; i < length - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]); 
            // 到达上次跳跃能到达的右边界了
            if (i == end) {
                // 目前能跳到的最远位置变成了下次起跳位置的有边界
                end = maxPosition;
                // 进入下一次跳跃
                steps++;
            }
        }
        return steps;
    }
}

```



## 62.不同路径

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>
> 问总共有多少条不同的路径？

```JAVA
class Solution {
     public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
}
```

组合数学方法

![image-20210819100612787](typora-user-images\image-20210819100612787.png)

下面是dp方法

![image-20210819100636780](typora-user-images\image-20210819100636780.png)

```JAVA
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] f = new int[m][n];
        for (int i = 0; i < m; ++i) {
            f[i][0] = 1;
        }
        for (int j = 0; j < n; ++j) {
            f[0][j] = 1;
        }
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        return f[m - 1][n - 1];
    }
}


```

## 5.最长回文子串

> 给你一个字符串 `s`，找到 `s` 中最长的回文子串。

 ![image-20210820195658906](typora-user-images\image-20210820195658906.png)

```JAVA
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```

## 413.等差数列划分

> 如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。
>
> 例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。
> 给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。
>
> 子数组 是数组中的一个连续序列。

```JAVA
class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        int n = nums.length;
        if (n <= 2) {
            return 0;
        }
        int[] dp = new int[n];
        dp[0] = 0;
        dp[1] = 0;
        int ans = 0;
        for (int i = 2;i < n ;i++ ) {
            if ((nums[i-1] - nums[i-2]) == nums[i] - nums[i-1]) {
                dp[i] = dp[i - 1]+1;
                ans += dp[i];
            }
        }
        return ans;
    }
}
```

![image-20210820201814023](typora-user-images\image-20210820201814023.png)

注意`dp[i]` 表示：**以 `nums[i]` 结尾的**、且长度大于等于 3 的连续等差数列的个数。

那么答案就是dp[2]+...+dp[n-1]

## 139.单词拆分

> 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
>
> 说明：
>
> 拆分时可以重复使用字典中的单词。
> 你可以假设字典中没有重复的单词。

```JAVA
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        boolean[] dp = new boolean[n+1];
        Set<String> set = new HashSet<>(wordDict);
        dp[0] = true;
        for (int i = 1;i <= n ;i++ ) {
            for (int j = 0; j < i ;j++ ) {
                if(dp[j] && set.contains(s.substring(j,i))){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
}
```

设dp[i]表示s[0...i-1]是否可以被拆分，那么dp[i] = dp[j] && (s[j....i-1]可以被拆分) 就是状态转移方程

## 91.解码方法

![image-20210821102648825](typora-user-images\image-20210821102648825.png)

![image-20210821102708840](typora-user-images\image-20210821102708840.png)

```JAVA
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int i = 1; i <= n; ++i) {
            if (s.charAt(i - 1) != '0') {
                f[i] += f[i - 1];
            }
            if (i > 1 && s.charAt(i - 2) != '0' && ((s.charAt(i - 2) - '0') * 10 + (s.charAt(i - 1) - '0') <= 26)) {
                f[i] += f[i - 2];
            }
        }
        return f[n];
    }
}
```

## 300.最长递增子序列

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
> 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```JAVA
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len == 1) {
            return 1;
        }
        int[] f = new int[len];
        f[0] = 1;
        int max = 1;
        for (int i = 1; i < len; i++) {
            f[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
            max = Math.max(f[i], max);
        }
        return max;
    }
}
```

维护一个数组f作为dp数组

![image-20210822111207443](typora-user-images\image-20210822111207443.png)

这种子序列等问题，dp数组多以dp[i]考虑前i个元素且nums[i]必须被选取为方法。

## 673.最长递增子序列的个数

> 给定一个未排序的整数数组，找到最长递增子序列的个数。

- 假设对于以 nums[i] 结尾的序列，我们知道最长序列的长度 length[i]，以及具有该长度的序列的 count[i]。
- 对于每一个 i<j 和一个 A[i]<A[j]，我们可以将一个 A[j] 附加到以 A[i] 结尾的最长子序列上。
- 如果这些序列比 length[j] 长，那么我们就知道我们有count[i] 个长度为 length 的序列。如果这些序列的长度与 length[j] 相等，那么我们就知道现在有 count[i] 个额外的序列（即 count[j]+=count[i]）。

> 1. 数组lengths[i]：其值表示包含第i个元素nums[i]且以其为结尾的最长递增子序列的长度。
> 2. 数组counts[i]: 其值表示以i为结尾的，且是所能得到的以nums[i]结尾的最长递增子序列长度的可能组合的个数。这里要注意每一个元素，可能的个数至少为1，因为最短也会包含它自己。
> 3. 注意双层for循环 j 在外层，i 在内层。
> 4. 如果 nums[i] < nums[j]，也就是说 j 〉i 时 nums[j] 比nums[i]大，也就是此时可以将nums[j] 添加到以nums[i]结尾的最长递增子序列的末尾。
> 5. 此时，如果以nums[i]结尾的最长递增子序列的长度lengths[i] 是大于等于以nums[j]结尾的最长递增子序列的长度lengths[j] 的，那么此时要更新以nums[j]结尾的最长递增子序列的长度，即lengths[j] = lengths[i] + 1，并且可以知道counts[j] = counts[i]；
> 6. 否则，如果以nums[i]结尾的最长递增子序列的长度lengths[i] 是小于以nums[j]结尾的最长递增子序列的长度lengths[j] 的，且此时lengths[i] + 1 == lengths[j]，即以nums[i]结尾的最长递增子序列加上nums[j]后的长度，刚好等于lengths[j]，那么此时所有以nums[i]结尾的最长递增子序列加上1后都符合要求，所以counts[j] += counts[i]；
> 7. 最后，根据数组lengths找到最长递增子序列的长度时的nums数组下标 i ，然后根据counts数组，获取个数即是答案。

```JAVA
class Solution {
    public int findNumberOfLIS(int[] nums) {
        int N = nums.length;
        if (N <= 1) return N;
        int[] lengths = new int[N]; //lengths[i] = length of longest ending in nums[i]
        int[] counts = new int[N]; //count[i] = number of longest ending in nums[i]
        Arrays.fill(counts, 1);

        for (int j = 0; j < N; ++j) {
            for (int i = 0; i < j; ++i) if (nums[i] < nums[j]) {
                if (lengths[i] >= lengths[j]) {
                    lengths[j] = lengths[i] + 1;
                    counts[j] = counts[i];
                } else if (lengths[i] + 1 == lengths[j]) {
                    counts[j] += counts[i];
                }
            }
        }

        int longest = 0, ans = 0;
        for (int length: lengths) {
            longest = Math.max(longest, length);
        }
        for (int i = 0; i < N; ++i) {
            if (lengths[i] == longest) {
                ans += counts[i];
            }
        }
        return ans;
    }
}

```

## 1143.最长公共子序列(二维dp经典)

> 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
>
> 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
>
> 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
> 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
>



```JAVA
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        //dp[i][j]表示text1[0:i]和text2[0:j]的最长公共子序列长度
        int[][] dp = new int[m + 1][n + 1];
        //dp边界
        for (int i = 0; i < m + 1; i++) {
            dp[i][0] = 0;
        }
        for (int i = 0; i < n + 1; i++) {
            dp[0][i] = 0;
        }
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

![image-20210823115940613](typora-user-images\image-20210823115940613.png)

应注意`text1[0:i]`的末尾是`text1.charAt(i-1)`

## 583.两个字符串的删除操作

> 给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

```JAVA
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        //dp[i][j]表示word1[0:i]和word2[0:j]的最长公共子序列长度
        int[][] dp = new int[m + 1][n + 1];
        //dp边界
        for (int i = 0; i < m + 1; i++) {
            dp[i][0] = 0;
        }
        for (int i = 0; i < n + 1; i++) {
            dp[0][i] = 0;
        }
        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        //两个字符串最长公共子序列的长度
        int len = dp[m][n];
        return m + n - 2 * len;
    }
}
```

实际上就是求两个字符串的最长公共子串。

## 72.编辑距离(困难二维DP)

> 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
>
> 你可以对一个单词进行如下三种操作：
>
> 插入一个字符
> 删除一个字符
> 替换一个字符

![image-20210824102814599](typora-user-images\image-20210824102814599.png)

![image-20210824102823385](typora-user-images\image-20210824102823385.png)

![image-20210824102830856](typora-user-images\image-20210824102830856.png)

![image-20210824102839030](typora-user-images\image-20210824102839030.png)

```JAVA
class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length();
        int m = word2.length();

        // 有一个字符串为空串
        if (n * m == 0) {
            return n + m;
        }

        // DP 数组
        int[][] D = new int[n + 1][m + 1];

        // 边界状态初始化
        for (int i = 0; i < n + 1; i++) {
            D[i][0] = i;
        }
        for (int j = 0; j < m + 1; j++) {
            D[0][j] = j;
        }

        // 计算所有 DP 值
        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < m + 1; j++) {
                int left = D[i - 1][j];
                int down = D[i][j - 1];
                int left_down = D[i - 1][j - 1];
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    D[i][j] = Math.min(left, Math.min(down, left_down - 1)) + 1;
                } else {
                    D[i][j] = Math.min(left, Math.min(down, left_down)) + 1;
                }

            }
        }
        return D[n][m];
    }
}
```



## 322.零钱兑换

> 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
>
> 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

腾讯二面试题。

经典动态规划，对amount动归，由i枚举，`dp[i] = min(dp[i-coins[j]])+1;`

这里定义了一个max来辅助`dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);`而且能保证不存在兑换情况时被区分出来。

```JAVA
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        int max = amount + 1;
        Arrays.fill(dp, max);
        dp[0] = 0;
        int n = coins.length;
        for (int i = 1; i < amount + 1; i++) {
            for (int j = 0; j < n; j++) {
                if (i >= coins[j]) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

## 343.整数拆分

> 给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

同剑指offer剪绳子，由数学求导可以得到x=e时取极值，由于x整数，取x=3，拆分成尽可能多的3可以得到极值，所以根据n模3分类即可。

![image-20210824090357307](typora-user-images\image-20210824090357307.png)

```JAVA
class Solution {
    public int integerBreak(int n) {
        int k = n / 3;
        if (k == 0) {
            return 1;
        } else if (k == 1) {
            switch (n) {
                case 3:
                    return 2;
                case 4:
                    return 4;
                default:
                    return 6;
            }
        }
        switch (n % 3) {
            case 0: {
                return (int) Math.pow(3, k);
            }
            case 1: {
                return (int) Math.pow(3, k - 1) * 4;
            }
            default: {
                return (int) Math.pow(3, k) * 2;
            }
        }
    }
}
```



# 位运算

## 231.2的幂

>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。



 ```JAVA
 class Solution {
     public boolean isPowerOfTwo(int n) {
         if(n == 1){
             return true;
         }
         while (n % 2 == 0 && n != 0){
             if(n == 2){
                 return true;
             }else{
                 n /= 2;
             }
         }
         return false;
     }
 }
 ```



## 191.位1的个数

>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
>
>提示：
>
>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

 

```JAVA
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            if ((n & (1 << i)) != 0) {
                ret++;
            }
        }
        return ret;
    }
}
```

本题的核心思路在 判断第i位是否为1 就让n和2的i次方（1左移i位）进行与运算。

## 190.颠倒的二进制位

> 颠倒给定的 32 位无符号整数的二进制位。

将 n 视作一个长为 32的二进制串，从低位往高位枚举 n的每一位，将其倒序添加到翻转结果 rev 中。

代码实现中，每枚举一位就将 n 右移一位，这样当前 n 的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。

需要注意的是，在某些语言（如Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。



```JAVA
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int rev = 0;
        for (int i = 0; i < 32 && n != 0; ++i) {
            //n&1是n的最低位 将其颠倒就是放到31-i处 然后进行或操作
            rev |= (n & 1) << (31 - i);
            n >>>= 1;
        }
        return rev;
    }
}
```

## 136.只出现一次的数字

> 给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

```JAVA
class Solution {
    public int singleNumber(int[] nums) {
        int single = 0;
        for (int num : nums) {
            single ^= num;
        }
        return single;

    }
}
```

数组中的全部元素的异或运算结果即为数组中只出现一次的数字。

## 201.数字范围按位与

> 给你两个整数 `left` 和 `right` ，表示区间 `[left, right]` ，返回此区间内所有数字 **按位与** 的结果（包含 `left` 、`right` 端点）。



```JAVA
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int shift = 0;
        // 找到公共前缀
        while (m < n) {
            m >>= 1;
            n >>= 1;
            ++shift;
        }
        return m << shift;
    }
}

```

![image-20210825105940164](typora-user-images\image-20210825105940164.png)

找公共前缀就每步右移一位，当m==n的时候终止，并记录右移位数，再另一个数左移回来，就是答案。

# 其他

## 384.打乱数组

> 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
>
> 实现 Solution class:
>
> Solution(int[] nums) 使用整数数组 nums 初始化对象
> int[] reset() 重设数组到它的初始状态并返回
> int[] shuffle() 返回数组随机打乱后的结果

Java中Collections类自带shuffle方法：

```JAVA
class Solution {

    private int[] nums;
    private int[] origin;

    public Solution(int[] nums) {
        this.nums = nums;
        this.origin = nums.clone();
    }

    /**
     * Resets the array to its original configuration and return it.
     */
    public int[] reset() {
        nums = origin;
        origin = origin.clone();
        return this.origin;
    }

    /**
     * Returns a random shuffling of the array.
     */
    public int[] shuffle() {
        List<Integer> list = new ArrayList<>(nums.length);
        for (int i = 0; i < nums.length; i++) {
            list.add(nums[i]);
        }
        Collections.shuffle(list);
        for (int i = 0; i < list.size(); i++) {
            nums[i] = list.get(i);
        }
        return nums;
    }
}
```

正常做法：

Fisher-Yates 洗牌算法。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换 - 这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。此外还有一个需要注意的细节，当前元素是可以和它本身互相交换的 - 否则生成最后的排列组合的概率就不对了。

```JAVA
class Solution {

    private int[] nums;
    private int[] origin;
    Random rand = new Random();

    private int randRange(int min, int max) {
        return rand.nextInt(max - min) + min;
    }

    private void swapAt(int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }


    public Solution(int[] nums) {
        this.nums = nums;
        this.origin = nums.clone();
    }

    /**
     * Resets the array to its original configuration and return it.
     */
    public int[] reset() {
        nums = origin;
        origin = origin.clone();
        return this.origin;
    }

    /**
     * Returns a random shuffling of the array.
     */
    public int[] shuffle() {
        for (int i = 0; i < nums.length; i++) {
            swapAt(i, randRange(i, nums.length));
        }
        return nums;
    }
}

```

## 202.快乐数

> 编写一个算法来判断一个数 n 是不是快乐数。
>
> 「快乐数」定义为：
>
> 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
> 如果 可以变为  1，那么这个数就是快乐数。
> 如果 n 是快乐数就返回 true ；不是，则返回 false 。

![image-20210826093708073](typora-user-images\image-20210826093708073.png)

![image-20210826093816012](typora-user-images\image-20210826093816012.png)

```JAVA
class Solution {
    //替换为每一位的平方和
    public int next(int n){
        int sum = 0;
        while(n > 0){
            int d = n % 10;
            n /= 10;
            sum += Math.pow(d,2);
        }
        return sum;
    }
    public boolean isHappy(int n) {
        HashSet<Integer> set = new HashSet<>();
        for(;!set.contains(n);n = next(n)){
            if(n == 1){
                return true;
            }else{
                set.add(n);
            }
        }
        return false;
    }
}
```

## 149.直线上最多的点数

> 给你一个数组 `points` ，其中 `points[i] = [xi, yi]` 表示 **X-Y** 平面上的一个点。求最多有多少个点在同一条直线上。



```JAVA
int maxPoints(int[][] ps) {
        int n = ps.length;
        int ans = 1;
        for (int i = 0; i < n; i++) {
            int[] x = ps[i];
            for (int j = i + 1; j < n; j++) {
                int[] y = ps[j];
                int cnt = 2;
                //枚举点x和y后面的所有点是否在x和y的所在直线
                //如果在 就记录
                for (int k = j + 1; k < n; k++) {
                    int[] p = ps[k];
                    //两个直线的斜率相等转为用乘法判断
                    //(y2-y1)*(x3-x2) = (y3-y2)*(x2-x1)
                    int s1 = (y[1] - x[1]) * (p[0] - y[0]);
                    int s2 = (p[1] - y[1]) * (y[0] - x[0]);
                    if (s1 == s2) {
                        cnt++;
                    }
                }
                //更新每一个由x和y得到的ans
                ans = Math.max(ans, cnt);
            }
        }
        return ans;
    }
}
```

优化：

根据「朴素解法」的思路，枚举所有直线的过程不可避免，但统计点数的过程可以优化。

具体的，我们可以先枚举所有可能出现的 直线斜率（根据两点确定一条直线，即枚举所有的「点对」），使用「哈希表」统计所有 斜率 对应的点的数量，在所有值中取个 max 即是答案。

一些细节：在使用「哈希表」进行保存时，为了避免精度问题，我们直接使用字符串进行保存，同时需要将 斜率 约干净。

```JAVA
class Solution {
    public int maxPoints(int[][] ps) {
        int n = ps.length;
        int ans = 1;
        for (int i = 0; i < n; i++) {
            Map<String, Integer> map = new HashMap<>();
            // 由当前点 i 发出的直线所经过的最多点数量
            int max = 0;
            for (int j = i + 1; j < n; j++) {
                int x1 = ps[i][0], y1 = ps[i][1], x2 = ps[j][0], y2 = ps[j][1];
                int a = x1 - x2, b = y1 - y2;
                int k = gcd(a, b);
                String key = (a / k) + "_" + (b / k);
                map.put(key, map.getOrDefault(key, 0) + 1);
                max = Math.max(max, map.get(key));
            }
            ans = Math.max(ans, max + 1);
        }
        return ans;
    }
    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}

```

